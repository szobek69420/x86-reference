<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:svg="http://www.w3.org/2000/svg" xmlns:x86="http://www.felixcloutier.com/x86">
<!-- Mirrored from www.felixcloutier.com/x86/vucomish by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 02 Jun 2025 23:57:57 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link rel="stylesheet" type="text/css" href="style.css"></link><title>VUCOMISH
		— Unordered Compare Scalar FP16 Values and Set EFLAGS</title></head><body><header><nav><ul><li><a href='index.html'>Index</a></li><li>December 2023</li></ul></nav></header><h1>VUCOMISH
		— Unordered Compare Scalar FP16 Values and Set EFLAGS</h1>

<table>
<tr>
<td><strong> Instruction En bit Mode Flag
Support  Instruction En bit Mode Flag
Support  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag  Op/ 64/32 CPUID Feature Instruction En bit Mode Flag  64/32 CPUID Feature Instruction En bit Mode Flag  CPUID Feature Instruction En bit Mode Flag p/ 64/32 CPUID Feature Instruction En bit Mode Flag
Support
Description
</strong>EVEX.LLIG.NP.MAP5.W0 2E /r A V/V AVX512-FP16  <strong>Description
</strong>EVEX.LLIG.NP.MAP5.W0 2E /r A V/V AVX512-FP16 VUCOMISH xmm1, xmm2/m16 {sae} <strong>Description
</strong>EVEX.LLIG.NP.MAP5.W0 2E /r A V/V AVX512-FP16  <strong>Description
</strong>EVEX.LLIG.NP.MAP5.W0 2E /r A V/V AVX512-FP16  <strong> Op/ 64/32 CPUID Feature </strong></td>
<td></td>
<td><strong>Support</strong></td>
<td></td>
<td><strong>Description</strong></td></tr>
<tr>
<td>VUCOMISH xmm1, xmm2/m16 {sae}</td>
<td></td>
<td></td>
<td></td>
<td>Compare low FP16 values in xmm1 and xmm2/m16 and set the EFLAGS flags accordingly.</td></tr></table>
<h2 id="instruction-operand-encoding">Instruction Operand Encoding<a class="anchor" href="#instruction-operand-encoding">
			¶
		</a></h2>
<table>
<tr>
<th>Op/En</th>
<th>Tuple</th>
<th>Operand 1</th>
<th>Operand 2</th>
<th>Operand 3</th>
<th>Operand 4</th></tr>
<tr>
<td>A</td>
<td>Scalar</td>
<td>ModRM:reg (w)</td>
<td>ModRM:r/m (r)</td>
<td>N/A</td>
<td>N/A</td></tr></table>
<h3 id="description">Description<a class="anchor" href="#description">
			¶
		</a></h3>
<p>This instruction compares the FP16 values in the low word of operand 1 (first operand) and operand 2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register according to the result (unordered, greater than, less than, or equal). The OF, SF and AF flags in the EFLAGS register are set to 0. The unordered result is returned if either source operand is a NaN (QNaN or SNaN).</p>
<p>Operand 1 is an XMM register; operand 2 can be an XMM register or a 16-bit memory location.</p>
<p>The VUCOMISH instruction differs from the VCOMISH instruction in that it signals a SIMD floating-point invalid operation exception (#I) only if a source operand is an SNaN. The COMISS instruction signals an invalid numeric exception when a source operand is either a QNaN or SNaN.</p>
<p>The EFLAGS register is not updated if an unmasked SIMD floating-point exception is generated. EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.</p>
<h3 id="operation">Operation<a class="anchor" href="#operation">
			¶
		</a></h3>
<h4 id="vucomish">VUCOMISH<a class="anchor" href="#vucomish">
			¶
		</a></h4>
<pre>RESULT := UnorderedCompare(SRC1.fp16[0],SRC2.fp16[0])
if RESULT is UNORDERED:
    ZF, PF, CF := 1, 1, 1
else if RESULT is GREATER_THAN:
    ZF, PF, CF := 0, 0, 0
else if RESULT is LESS_THAN:
    ZF, PF, CF := 0, 0, 1
else: // RESULT is EQUALS
    ZF, PF, CF := 1, 0, 0
OF, AF, SF := 0, 0, 0
</pre>
<h3 id="intel-c-c++-compiler-intrinsic-equivalent">Intel C/C++ Compiler Intrinsic Equivalent<a class="anchor" href="#intel-c-c++-compiler-intrinsic-equivalent">
			¶
		</a></h3>
<pre>VUCOMISH int _mm_ucomieq_sh (__m128h a, __m128h b);
</pre>
<pre>VUCOMISH int _mm_ucomige_sh (__m128h a, __m128h b);
</pre>
<pre>VUCOMISH int _mm_ucomigt_sh (__m128h a, __m128h b);
</pre>
<pre>VUCOMISH int _mm_ucomile_sh (__m128h a, __m128h b);
</pre>
<pre>VUCOMISH int _mm_ucomilt_sh (__m128h a, __m128h b);
</pre>
<pre>VUCOMISH int _mm_ucomineq_sh (__m128h a, __m128h b);
</pre>
<h3 class="exceptions" id="simd-floating-point-exceptions">SIMD Floating-Point Exceptions<a class="anchor" href="#simd-floating-point-exceptions">
			¶
		</a></h3>
<p>Invalid, Denormal.</p>
<h3 class="exceptions" id="other-exceptions">Other Exceptions<a class="anchor" href="#other-exceptions">
			¶
		</a></h3>
<p>EVEX-encoded instructions, see <span class="not-imported">Table 2-48</span>, “Type E3NF Class Exception Conditions.”</p><footer><p>
		This UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be
		inc<span style="opacity: 0.2">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious
		ways. Refer to <a href="../../software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.
	</p></footer></body>
<!-- Mirrored from www.felixcloutier.com/x86/vucomish by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 02 Jun 2025 23:57:57 GMT -->
</html>
