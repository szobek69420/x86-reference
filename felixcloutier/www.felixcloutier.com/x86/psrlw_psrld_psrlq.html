<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:svg="http://www.w3.org/2000/svg" xmlns:x86="index.html">
<!-- Mirrored from www.felixcloutier.com/x86/psrlw:psrld:psrlq by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 02 Jun 2025 23:57:49 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link rel="stylesheet" type="text/css" href="style.css"></link><title>PSRLW/PSRLD/PSRLQ
		— Shift Packed Data Right Logical</title></head><body><header><nav><ul><li><a href='index.html'>Index</a></li><li>December 2023</li></ul></nav></header><h1>PSRLW/PSRLD/PSRLQ
		— Shift Packed Data Right Logical</h1>



<table>
<tr>
<th>Opcode/Instruction</th>
<th>Op/En</th>
<th>64/32 bit Mode Support</th>
<th>CPUID Feature Flag</th>
<th>Description</th></tr>
<tr>
<td>NP 0F D1 /r<sup>1</sup> PSRLW mm, mm/m64</td>
<td>A</td>
<td>V/V</td>
<td>MMX</td>
<td>Shift words in mm right by amount specified in mm/m64 while shifting in 0s.</td></tr>
<tr>
<td>66 0F D1 /r PSRLW xmm1, xmm2/m128</td>
<td>A</td>
<td>V/V</td>
<td>SSE2</td>
<td>Shift words in xmm1 right by amount specified in xmm2/m128 while shifting in 0s.</td></tr>
<tr>
<td>NP 0F 71 /2 ib<sup>1</sup> PSRLW mm, imm8</td>
<td>B</td>
<td>V/V</td>
<td>MMX</td>
<td>Shift words in mm right by imm8 while shifting in 0s.</td></tr>
<tr>
<td>66 0F 71 /2 ib PSRLW xmm1, imm8</td>
<td>B</td>
<td>V/V</td>
<td>SSE2</td>
<td>Shift words in xmm1 right by imm8 while shifting in 0s.</td></tr>
<tr>
<td>NP 0F D2 /r<sup>1</sup> PSRLD mm, mm/m64</td>
<td>A</td>
<td>V/V</td>
<td>MMX</td>
<td>Shift doublewords in mm right by amount specified in mm/m64 while shifting in 0s.</td></tr>
<tr>
<td>66 0F D2 /r PSRLD xmm1, xmm2/m128</td>
<td>A</td>
<td>V/V</td>
<td>SSE2</td>
<td>Shift doublewords in xmm1 right by amount specified in xmm2 /m128 while shifting in 0s.</td></tr>
<tr>
<td>NP 0F 72 /2 ib<sup>1</sup> PSRLD mm, imm8</td>
<td>B</td>
<td>V/V</td>
<td>MMX</td>
<td>Shift doublewords in mm right by imm8 while shifting in 0s.</td></tr>
<tr>
<td>66 0F 72 /2 ib PSRLD xmm1, imm8</td>
<td>B</td>
<td>V/V</td>
<td>SSE2</td>
<td>Shift doublewords in xmm1 right by imm8 while shifting in 0s.</td></tr>
<tr>
<td>NP 0F D3 /r<sup>1</sup> PSRLQ mm, mm/m64</td>
<td>A</td>
<td>V/V</td>
<td>MMX</td>
<td>Shift mm right by amount specified in mm/m64 while shifting in 0s.</td></tr>
<tr>
<td>66 0F D3 /r PSRLQ xmm1, xmm2/m128</td>
<td>A</td>
<td>V/V</td>
<td>SSE2</td>
<td>Shift quadwords in xmm1 right by amount specified in xmm2/m128 while shifting in 0s.</td></tr>
<tr>
<td>NP 0F 73 /2 ib<sup>1</sup> PSRLQ mm, imm8</td>
<td>B</td>
<td>V/V</td>
<td>MMX</td>
<td>Shift mm right by imm8 while shifting in 0s.</td></tr>
<tr>
<td>66 0F 73 /2 ib PSRLQ xmm1, imm8</td>
<td>B</td>
<td>V/V</td>
<td>SSE2</td>
<td>Shift quadwords in xmm1 right by imm8 while shifting in 0s.</td></tr>
<tr>
<td>VEX.128.66.0F.WIG D1 /r VPSRLW xmm1, xmm2, xmm3/m128</td>
<td>C</td>
<td>V/V</td>
<td>AVX</td>
<td>Shift words in xmm2 right by amount specified in xmm3/m128 while shifting in 0s.</td></tr>
<tr>
<td>VEX.128.66.0F.WIG 71 /2 ib VPSRLW xmm1, xmm2, imm8</td>
<td>D</td>
<td>V/V</td>
<td>AVX</td>
<td>Shift words in xmm2 right by imm8 while shifting in 0s.</td></tr>
<tr>
<td>VEX.128.66.0F.WIG D2 /r VPSRLD xmm1, xmm2, xmm3/m128</td>
<td>C</td>
<td>V/V</td>
<td>AVX</td>
<td>Shift doublewords in xmm2 right by amount specified in xmm3/m128 while shifting in 0s.</td></tr>
<tr>
<td>VEX.128.66.0F.WIG 72 /2 ib VPSRLD xmm1, xmm2, imm8</td>
<td>D</td>
<td>V/V</td>
<td>AVX</td>
<td>Shift doublewords in xmm2 right by imm8 while shifting in 0s.</td></tr>
<tr>
<td>VEX.128.66.0F.WIG D3 /r VPSRLQ xmm1, xmm2, xmm3/m128</td>
<td>C</td>
<td>V/V</td>
<td>AVX</td>
<td>Shift quadwords in xmm2 right by amount specified in xmm3/m128 while shifting in 0s.</td></tr>
<tr>
<td>VEX.128.66.0F.WIG 73 /2 ib VPSRLQ xmm1, xmm2, imm8</td>
<td>D</td>
<td>V/V</td>
<td>AVX</td>
<td>Shift quadwords in xmm2 right by imm8 while shifting in 0s.</td></tr>
<tr>
<td>VEX.256.66.0F.WIG D1 /r VPSRLW ymm1, ymm2, xmm3/m128</td>
<td>C</td>
<td>V/V</td>
<td>AVX2</td>
<td>Shift words in ymm2 right by amount specified in xmm3/m128 while shifting in 0s.</td></tr>
<tr>
<td>VEX.256.66.0F.WIG 71 /2 ib VPSRLW ymm1, ymm2, imm8</td>
<td>D</td>
<td>V/V</td>
<td>AVX2</td>
<td>Shift words in ymm2 right by imm8 while shifting in 0s.</td></tr>
<tr>
<td>VEX.256.66.0F.WIG D2 /r VPSRLD ymm1, ymm2, xmm3/m128</td>
<td>C</td>
<td>V/V</td>
<td>AVX2</td>
<td>Shift doublewords in ymm2 right by amount specified in xmm3/m128 while shifting in 0s.</td></tr>
<tr>
<td>VEX.256.66.0F.WIG 72 /2 ib VPSRLD ymm1, ymm2, imm8</td>
<td>D</td>
<td>V/V</td>
<td>AVX2</td>
<td>Shift doublewords in ymm2 right by imm8 while shifting in 0s.</td></tr>
<tr>
<td>VEX.256.66.0F.WIG D3 /r VPSRLQ ymm1, ymm2, xmm3/m128</td>
<td>C</td>
<td>V/V</td>
<td>AVX2</td>
<td>Shift quadwords in ymm2 right by amount specified in xmm3/m128 while shifting in 0s.</td></tr>
<tr>
<td>VEX.256.66.0F.WIG 73 /2 ib VPSRLQ ymm1, ymm2, imm8</td>
<td>D</td>
<td>V/V</td>
<td>AVX2</td>
<td>Shift quadwords in ymm2 right by imm8 while shifting in 0s.</td></tr>
<tr>
<td>EVEX.128.66.0F.WIG D1 /r VPSRLW xmm1 {k1}{z}, xmm2, xmm3/m128</td>
<td>G</td>
<td>V/V</td>
<td>AVX512VL AVX512BW</td>
<td>Shift words in xmm2 right by amount specified in xmm3/m128 while shifting in 0s using writemask k1.</td></tr>
<tr>
<td>EVEX.256.66.0F.WIG D1 /r VPSRLW ymm1 {k1}{z}, ymm2, xmm3/m128</td>
<td>G</td>
<td>V/V</td>
<td>AVX512VL AVX512BW</td>
<td>Shift words in ymm2 right by amount specified in xmm3/m128 while shifting in 0s using writemask k1.</td></tr>
<tr>
<td>EVEX.512.66.0F.WIG D1 /r VPSRLW zmm1 {k1}{z}, zmm2, xmm3/m128</td>
<td>G</td>
<td>V/V</td>
<td>AVX512BW</td>
<td>Shift words in zmm2 right by amount specified in xmm3/m128 while shifting in 0s using writemask k1.</td></tr>
<tr>
<td>EVEX.128.66.0F.WIG 71 /2 ib VPSRLW xmm1 {k1}{z}, xmm2/m128, imm8</td>
<td>E</td>
<td>V/V</td>
<td>AVX512VL AVX512BW</td>
<td>Shift words in xmm2/m128 right by imm8 while shifting in 0s using writemask k1.</td></tr>
<tr>
<td>EVEX.256.66.0F.WIG 71 /2 ib VPSRLW ymm1 {k1}{z}, ymm2/m256, imm8</td>
<td>E</td>
<td>V/V</td>
<td>AVX512VL AVX512BW</td>
<td>Shift words in ymm2/m256 right by imm8 while shifting in 0s using writemask k1.</td></tr>
<tr>
<td>EVEX.512.66.0F.WIG 71 /2 ib VPSRLW zmm1 {k1}{z}, zmm2/m512, imm8</td>
<td>E</td>
<td>V/V</td>
<td>AVX512BW</td>
<td>Shift words in zmm2/m512 right by imm8 while shifting in 0s using writemask k1.</td></tr>
<tr>
<td>EVEX.128.66.0F.W0 D2 /r VPSRLD xmm1 {k1}{z}, xmm2, xmm3/m128</td>
<td>G</td>
<td>V/V</td>
<td>AVX512VL AVX512F</td>
<td>Shift doublewords in xmm2 right by amount specified in xmm3/m128 while shifting in 0s using writemask k1.</td></tr>
<tr>
<td>EVEX.256.66.0F.W0 D2 /r VPSRLD ymm1 {k1}{z}, ymm2, xmm3/m128</td>
<td>G</td>
<td>V/V</td>
<td>AVX512VL AVX512F</td>
<td>Shift doublewords in ymm2 right by amount specified in xmm3/m128 while shifting in 0s using writemask k1.</td></tr>
<tr>
<td>EVEX.512.66.0F.W0 D2 /r VPSRLD zmm1 {k1}{z}, zmm2, xmm3/m128</td>
<td>G</td>
<td>V/V</td>
<td>AVX512F</td>
<td>Shift doublewords in zmm2 right by amount specified in xmm3/m128 while shifting in 0s using writemask k1.</td></tr>
<tr>
<td>EVEX.128.66.0F.W0 72 /2 ib VPSRLD xmm1 {k1}{z}, xmm2/m128/m32bcst, imm8</td>
<td>F</td>
<td>V/V</td>
<td>AVX512VL AVX512F</td>
<td>Shift doublewords in xmm2/m128/m32bcst right by imm8 while shifting in 0s using writemask k1.</td></tr>
<tr>
<td>EVEX.256.66.0F.W0 72 /2 ib VPSRLD ymm1 {k1}{z}, ymm2/m256/m32bcst, imm8</td>
<td>F</td>
<td>V/V</td>
<td>AVX512VL AVX512F</td>
<td>Shift doublewords in ymm2/m256/m32bcst right by imm8 while shifting in 0s using writemask k1.</td></tr>
<tr>
<td>EVEX.512.66.0F.W0 72 /2 ib VPSRLD zmm1 {k1}{z}, zmm2/m512/m32bcst, imm8</td>
<td>F</td>
<td>V/V</td>
<td>AVX512F</td>
<td>Shift doublewords in zmm2/m512/m32bcst right by imm8 while shifting in 0s using writemask k1.</td></tr>
<tr>
<td>EVEX.128.66.0F.W1 D3 /r VPSRLQ xmm1 {k1}{z}, xmm2, xmm3/m128</td>
<td>G</td>
<td>V/V</td>
<td>AVX512VL AVX512F</td>
<td>Shift quadwords in xmm2 right by amount specified in xmm3/m128 while shifting in 0s using writemask k1.</td></tr>
<tr>
<td>EVEX.256.66.0F.W1 D3 /r VPSRLQ ymm1 {k1}{z}, ymm2, xmm3/m128</td>
<td>G</td>
<td>V/V</td>
<td>AVX512VL AVX512F</td>
<td>Shift quadwords in ymm2 right by amount specified in xmm3/m128 while shifting in 0s using writemask k1.</td></tr>
<tr>
<td>EVEX.512.66.0F.W1 D3 /r VPSRLQ zmm1 {k1}{z}, zmm2, xmm3/m128</td>
<td>G</td>
<td>V/V</td>
<td>AVX512F</td>
<td>Shift quadwords in zmm2 right by amount specified in xmm3/m128 while shifting in 0s using writemask k1.</td></tr>
<tr>
<td>EVEX.128.66.0F.W1 73 /2 ib VPSRLQ xmm1 {k1}{z}, xmm2/m128/m64bcst, imm8</td>
<td>F</td>
<td>V/V</td>
<td>AVX512VL AVX512F</td>
<td>Shift quadwords in xmm2/m128/m64bcst right by imm8 while shifting in 0s using writemask k1.</td></tr>
<tr>
<td>EVEX.256.66.0F.W1 73 /2 ib VPSRLQ ymm1 {k1}{z}, ymm2/m256/m64bcst, imm8</td>
<td>F</td>
<td>V/V</td>
<td>AVX512VL AVX512F</td>
<td>Shift quadwords in ymm2/m256/m64bcst right by imm8 while shifting in 0s using writemask k1.</td></tr>
<tr>
<td>EVEX.512.66.0F.W1 73 /2 ib VPSRLQ zmm1 {k1}{z}, zmm2/m512/m64bcst, imm8</td>
<td>F</td>
<td>V/V</td>
<td>AVX512F</td>
<td>Shift quadwords in zmm2/m512/m64bcst right by imm8 while shifting in 0s using writemask k1.</td></tr></table>
<blockquote>
<p>1. See note in Section 2.5, “Intel® AVX and Intel® SSE Instruction Exception Classification,” in the Intel<sup>®</sup> 64 and IA-32 Architectures Software Developer’s Manual, Volume 2A, and Section 23.25.3, “Exception Conditions of Legacy SIMD Instructions Operating on MMX Registers,” in the Intel<sup>®</sup> 64 and IA-32 Architectures Software Developer’s Manual, Volume 3B.</p></blockquote>
<h2 id="instruction-operand-encoding">Instruction Operand Encoding<a class="anchor" href="#instruction-operand-encoding">
			¶
		</a></h2>
<table>
<tr>
<th>Op/En</th>
<th>Tuple Type</th>
<th>Operand 1</th>
<th>Operand 2</th>
<th>Operand 3</th>
<th>Operand 4</th></tr>
<tr>
<td>A</td>
<td>N/A</td>
<td>ModRM:reg (r, w)</td>
<td>ModRM:r/m (r)</td>
<td>N/A</td>
<td>N/A</td></tr>
<tr>
<td>B</td>
<td>N/A</td>
<td>ModRM:r/m (r, w)</td>
<td>imm8</td>
<td>N/A</td>
<td>N/A</td></tr>
<tr>
<td>C</td>
<td>N/A</td>
<td>ModRM:reg (w)</td>
<td>VEX.vvvv (r)</td>
<td>ModRM:r/m (r)</td>
<td>N/A</td></tr>
<tr>
<td>D</td>
<td>N/A</td>
<td>VEX.vvvv (w)</td>
<td>ModRM:r/m (r)</td>
<td>imm8</td>
<td>N/A</td></tr>
<tr>
<td>E</td>
<td>Full Mem</td>
<td>EVEX.vvvv (w)</td>
<td>ModRM:r/m (r)</td>
<td>imm8</td>
<td>N/A</td></tr>
<tr>
<td>F</td>
<td>Full</td>
<td>EVEX.vvvv (w)</td>
<td>ModRM:r/m (r)</td>
<td>imm8</td>
<td>N/A</td></tr>
<tr>
<td>G</td>
<td>Mem128</td>
<td>ModRM:reg (w)</td>
<td>EVEX.vvvv (r)</td>
<td>ModRM:r/m (r)</td>
<td>N/A</td></tr></table>
<h2 id="description">Description<a class="anchor" href="#description">
			¶
		</a></h2>
<p>Shifts the bits in the individual data elements (words, doublewords, or quadword) in the destination operand (first operand) to the right by the number of bits specified in the count operand (second operand). As the bits in the data elements are shifted right, the empty high-order bits are cleared (set to 0). If the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for a quadword), then the destination operand is set to all 0s. <a href='psrlw_psrld_psrlq.html#fig-4-19'>Figure 4-19</a> gives an example of shifting words in a 64-bit operand.</p>
<p>Note that only the low 64-bits of a 128-bit count operand are checked to compute the count.</p>
<figure id="fig-4-19">
<svg style="width: 455.616pt; height: 106.34399999999997pt" viewBox="109.64 0.0 384.68 93.61999999999998">
<g xmlns="http://www.w3.org/2000/svg" style="fill: none; stroke: none">
<rect height="87.66" style="fill: rgb(0%, 0%, 0%)" width="0.48" x="112.14" y="0.47999999999998977"></rect>
<rect height="87.66" style="fill: rgb(0%, 0%, 0%)" width="0.47998" x="491.34000000000003" y="0.47999999999998977"></rect>
<rect height="0.48" style="fill: rgb(0%, 0%, 0%)" width="379.68" x="112.14" y="0.0"></rect>
<rect height="0.48001000000000005" style="fill: rgb(0%, 0%, 0%)" width="379.68" x="112.14" y="88.13998999999998"></rect>
<rect height="0.48001000000000005" style="fill: rgb(0%, 0%, 0%)" width="63.120000000000005" x="194.70000000000002" y="11.159989999999993"></rect>
<rect height="18.240000000000002" style="fill: rgb(0%, 0%, 0%)" width="0.48001000000000005" x="257.34000000000003" y="11.399999999999977"></rect>
<rect height="0.48001000000000005" style="fill: rgb(0%, 0%, 0%)" width="63.120000000000005" x="194.46" y="29.159989999999993"></rect>
<rect height="18.240000000000002" style="fill: rgb(0%, 0%, 0%)" width="0.47998" x="194.46" y="11.159999999999968"></rect>
<rect height="18.0" style="fill: rgb(100%, 100%, 100%)" width="62.88" x="257.58" y="11.399999999999977"></rect>
<rect height="0.48001000000000005" style="fill: rgb(0%, 0%, 0%)" width="63.120000000000005" x="257.58" y="11.159989999999993"></rect>
<rect height="18.240000000000002" style="fill: rgb(0%, 0%, 0%)" width="0.48001000000000005" x="320.22" y="11.399999999999977"></rect>
<rect height="0.48001000000000005" style="fill: rgb(0%, 0%, 0%)" width="63.120000000000005" x="257.34000000000003" y="29.159989999999993"></rect>
<rect height="18.240000000000002" style="fill: rgb(0%, 0%, 0%)" width="0.48001000000000005" x="257.34000000000003" y="11.159999999999968"></rect>
<rect height="18.0" style="fill: rgb(100%, 100%, 100%)" width="62.940000000000005" x="320.46" y="11.399999999999977"></rect>
<rect height="0.48001000000000005" style="fill: rgb(0%, 0%, 0%)" width="63.18" x="320.46" y="11.159989999999993"></rect>
<rect height="18.240000000000002" style="fill: rgb(0%, 0%, 0%)" width="0.48001000000000005" x="383.16" y="11.399999999999977"></rect>
<rect height="0.48001000000000005" style="fill: rgb(0%, 0%, 0%)" width="63.18" x="320.22" y="29.159989999999993"></rect>
<rect height="18.240000000000002" style="fill: rgb(0%, 0%, 0%)" width="0.48001000000000005" x="320.22" y="11.159999999999968"></rect>
<rect height="18.0" style="fill: rgb(100%, 100%, 100%)" width="62.88" x="383.40000000000003" y="11.399999999999977"></rect>
<rect height="0.48001000000000005" style="fill: rgb(0%, 0%, 0%)" width="63.120000000000005" x="383.40000000000003" y="11.159989999999993"></rect>
<rect height="18.240000000000002" style="fill: rgb(0%, 0%, 0%)" width="0.47998" x="446.04" y="11.399999999999977"></rect>
<rect height="0.48001000000000005" style="fill: rgb(0%, 0%, 0%)" width="63.120000000000005" x="383.16" y="29.159989999999993"></rect>
<rect height="18.240000000000002" style="fill: rgb(0%, 0%, 0%)" width="0.48001000000000005" x="383.16" y="11.159999999999968"></rect>
<rect height="18.0" style="fill: rgb(100%, 100%, 100%)" width="62.940000000000005" x="194.10000000000002" y="64.37999999999997"></rect>
<rect height="0.48" style="fill: rgb(0%, 0%, 0%)" width="63.18" x="194.10000000000002" y="64.13999999999999"></rect>
<rect height="18.240000000000002" style="fill: rgb(0%, 0%, 0%)" width="0.48001000000000005" x="256.8" y="64.37999999999997"></rect>
<rect height="0.48001000000000005" style="fill: rgb(0%, 0%, 0%)" width="63.18" x="193.86" y="82.13998999999998"></rect>
<rect height="18.240000000000002" style="fill: rgb(0%, 0%, 0%)" width="0.48" x="193.86" y="64.13999999999999"></rect>
<rect height="18.0" style="fill: rgb(100%, 100%, 100%)" width="62.88" x="257.04" y="64.37999999999997"></rect>
<rect height="0.48" style="fill: rgb(0%, 0%, 0%)" width="63.120000000000005" x="257.04" y="64.13999999999999"></rect>
<rect height="18.240000000000002" style="fill: rgb(0%, 0%, 0%)" width="0.48001000000000005" x="319.68" y="64.37999999999997"></rect>
<rect height="0.48001000000000005" style="fill: rgb(0%, 0%, 0%)" width="63.120000000000005" x="256.8" y="82.13998999999998"></rect>
<rect height="18.240000000000002" style="fill: rgb(0%, 0%, 0%)" width="0.48001000000000005" x="256.8" y="64.13999999999999"></rect>
<rect height="18.0" style="fill: rgb(100%, 100%, 100%)" width="62.88" x="319.92" y="64.37999999999997"></rect>
<rect height="0.48" style="fill: rgb(0%, 0%, 0%)" width="63.120000000000005" x="319.92" y="64.13999999999999"></rect>
<rect height="18.240000000000002" style="fill: rgb(0%, 0%, 0%)" width="0.48001000000000005" x="382.56" y="64.37999999999997"></rect>
<rect height="0.48001000000000005" style="fill: rgb(0%, 0%, 0%)" width="63.120000000000005" x="319.68" y="82.13998999999998"></rect>
<rect height="18.240000000000002" style="fill: rgb(0%, 0%, 0%)" width="0.48001000000000005" x="319.68" y="64.13999999999999"></rect>
<rect height="18.0" style="fill: rgb(100%, 100%, 100%)" width="62.88" x="382.8" y="64.37999999999997"></rect>
<rect height="0.48" style="fill: rgb(0%, 0%, 0%)" width="63.120000000000005" x="382.8" y="64.13999999999999"></rect>
<rect height="18.240000000000002" style="fill: rgb(0%, 0%, 0%)" width="0.48001000000000005" x="445.44" y="64.37999999999997"></rect>
<rect height="0.48001000000000005" style="fill: rgb(0%, 0%, 0%)" width="63.120000000000005" x="382.56" y="82.13998999999998"></rect>
<rect height="18.240000000000002" style="fill: rgb(0%, 0%, 0%)" width="0.48001000000000005" x="382.56" y="64.13999999999999"></rect>
<rect height="1.02" style="fill: rgb(0%, 0%, 0%)" width="0.47998" x="420.54" y="56.99999999999997"></rect>
<path d="M 420.6 57.53999999999999 L 422.16 57.0 L 423.12 56.639999999999986 L 422.82000000000005 57.66 L 421.26000000000005 63.06 L 420.78000000000003 64.73999999999998 L 420.3 63.06 L 418.74 57.66 L 418.44 56.639999999999986 L 419.40000000000003 57.0 L 419.70000000000005 57.359999999999985 L 421.26000000000005 62.75999999999999 L 420.3 63.06 L 420.3 62.75999999999999 L 421.86 57.359999999999985 L 422.82000000000005 57.66 L 422.52000000000004 57.95999999999998 L 420.96000000000004 58.5" style="fill: rgb(0%, 0%, 0%); fill-rule: nonzero"></path>
<path d="M 419.40000000000003 56.99999999999997 L 420.96000000000004 57.539999999999964 L 420.96000000000004 58.49999999999997 L 420.78000000000003 58.559999999999974 L 420.6 58.49999999999997 L 419.04 57.95999999999998" style="fill: rgb(0%, 0%, 0%); fill-rule: nonzero"></path>
<path d="M 420.78000000000003 58.01999999999998 L 422.34000000000003 57.47999999999999 L 420.78000000000003 62.879999999999995 L 419.22 57.47999999999999" style="fill: rgb(0%, 0%, 0%); fill-rule: evenodd"></path>
<rect height="14.94" style="fill: rgb(0%, 0%, 0%)" width="0.47998" x="394.8" y="29.639999999999986"></rect>
<rect height="0.48001000000000005" style="fill: rgb(0%, 0%, 0%)" width="25.98" x="395.04" y="44.09998999999999"></rect>
<rect height="12.9" style="fill: rgb(0%, 0%, 0%)" width="0.47998" x="420.54" y="44.339999999999975"></rect>
<rect height="1.08" style="fill: rgb(0%, 0%, 0%)" width="0.48001000000000005" x="238.38" y="56.93999999999997"></rect>
<path d="M 238.44 57.53999999999999 L 239.94 56.94 L 240.9 56.51999999999998 L 239.1 63.0 L 238.62 64.67999999999998 L 238.14 63.0 L 236.57999999999998 57.599999999999994 L 236.28 56.579999999999984 L 237.24 56.94 L 237.54 57.29999999999998 L 239.1 62.69999999999999 L 238.14 63.0 L 238.14 62.69999999999999 L 239.64 57.29999999999998 L 240.6 57.599999999999994 L 240.3 57.900000000000006 L 238.8 58.5" style="fill: rgb(0%, 0%, 0%); fill-rule: nonzero"></path>
<path d="M 237.24 56.93999999999997 L 238.8 57.539999999999964 L 238.8 58.49999999999997 L 238.62 58.559999999999974 L 238.44 58.49999999999997 L 236.88 57.89999999999998" style="fill: rgb(0%, 0%, 0%); fill-rule: nonzero"></path>
<path d="M 238.62 58.01999999999998 L 240.12 57.41999999999999 L 238.62 62.81999999999999 L 237.06 57.41999999999999" style="fill: rgb(0%, 0%, 0%); fill-rule: evenodd"></path>
<rect height="14.94" style="fill: rgb(0%, 0%, 0%)" width="0.48" x="212.64000000000001" y="29.579999999999984"></rect>
<rect height="0.48" style="fill: rgb(0%, 0%, 0%)" width="25.98" x="212.88" y="44.03999999999999"></rect>
<rect height="12.9" style="fill: rgb(0%, 0%, 0%)" width="0.48001000000000005" x="238.38" y="44.27999999999997"></rect>
<rect height="1.02" style="fill: rgb(0%, 0%, 0%)" width="0.47998" x="302.1" y="56.93999999999997"></rect>
<path d="M 302.16 57.47999999999999 L 303.66 56.94 L 304.62 56.51999999999998 L 304.32000000000005 57.599999999999994 L 302.82000000000005 62.94 L 302.34000000000003 64.56 L 301.86 62.94 L 300.3 57.599999999999994 L 300.0 56.579999999999984 L 300.96000000000004 56.94 L 301.26000000000005 57.29999999999998 L 302.82000000000005 62.639999999999986 L 301.86 62.94 L 301.86 62.639999999999986 L 303.36 57.29999999999998 L 304.32000000000005 57.599999999999994 L 304.02000000000004 57.89999999999998 L 302.52000000000004 58.44" style="fill: rgb(0%, 0%, 0%); fill-rule: nonzero"></path>
<path d="M 300.96 56.93999999999997 L 302.52 57.47999999999996 L 302.52 58.43999999999997 L 302.34 58.49999999999997 L 302.15999999999997 58.43999999999997 L 300.59999999999997 57.89999999999998" style="fill: rgb(0%, 0%, 0%); fill-rule: nonzero"></path>
<path d="M 302.34000000000003 57.95999999999998 L 303.84000000000003 57.41999999999999 L 302.34000000000003 62.75999999999999 L 300.78000000000003 57.41999999999999" style="fill: rgb(0%, 0%, 0%); fill-rule: evenodd"></path>
<rect height="14.94" style="fill: rgb(0%, 0%, 0%)" width="0.47998" x="276.36" y="29.519999999999982"></rect>
<rect height="0.48" style="fill: rgb(0%, 0%, 0%)" width="25.98" x="276.6" y="43.97999999999999"></rect>
<rect height="12.96" style="fill: rgb(0%, 0%, 0%)" width="0.47998" x="302.1" y="44.21999999999997"></rect>
<rect height="1.08" style="fill: rgb(0%, 0%, 0%)" width="0.47998" x="358.8" y="57.41999999999996"></rect>
<path d="M 358.86 58.01999999999998 L 360.42 57.41999999999999 L 361.38 57.059999999999974 L 361.08000000000004 58.079999999999984 L 359.52000000000004 63.47999999999999 L 359.04 65.21999999999997 L 358.56 63.47999999999999 L 357.06 58.079999999999984 L 356.76 57.059999999999974 L 357.72 57.41999999999999 L 358.02000000000004 57.77999999999997 L 359.52000000000004 63.17999999999998 L 358.56 63.47999999999999 L 358.56 63.17999999999998 L 360.12 57.77999999999997 L 361.08000000000004 58.079999999999984 L 360.78000000000003 58.379999999999995 L 359.22 58.97999999999999" style="fill: rgb(0%, 0%, 0%); fill-rule: nonzero"></path>
<path d="M 357.72 57.41999999999999 L 359.22 58.01999999999998 L 359.22 58.97999999999999 L 359.04 59.03999999999999 L 358.86 58.97999999999999 L 357.36 58.379999999999995" style="fill: rgb(0%, 0%, 0%); fill-rule: nonzero"></path>
<path d="M 359.04 58.49999999999997 L 360.6 57.89999999999998 L 359.04 63.29999999999998 L 357.54 57.89999999999998" style="fill: rgb(0%, 0%, 0%); fill-rule: evenodd"></path>
<rect height="14.94" style="fill: rgb(0%, 0%, 0%)" width="0.48001000000000005" x="333.12" y="30.059999999999974"></rect>
<rect height="0.48001000000000005" style="fill: rgb(0%, 0%, 0%)" width="25.92" x="333.36" y="44.51998999999998"></rect>
<rect height="12.9" style="fill: rgb(0%, 0%, 0%)" width="0.47998" x="358.8" y="44.75999999999996"></rect>
<text lengthAdjust="spacingAndGlyphs" style="font-size: 8.917956000000004pt; fill: #000" textLength="31.14172609999997" x="160.07982600000003" y="21.185826799999973">Pre-Shift</text>
<text lengthAdjust="spacingAndGlyphs" style="font-size: 8.917956000000004pt; fill: #000" textLength="9.783381300000002" x="220.9211901" y="25.266648499999974">X3</text>
<text lengthAdjust="spacingAndGlyphs" style="font-size: 8.917956000000004pt; fill: #000" textLength="9.783381299999974" x="284.6398259" y="25.266648499999974">X2</text>
<text lengthAdjust="spacingAndGlyphs" style="font-size: 8.917956000000004pt; fill: #000" textLength="9.783381299999974" x="345.65910189999994" y="25.266648499999974">X1</text>
<text lengthAdjust="spacingAndGlyphs" style="font-size: 8.917956000000004pt; fill: #000" textLength="9.722649699999977" x="407.94" y="25.266100999999992">X0</text>
<text lengthAdjust="spacingAndGlyphs" style="font-size: 8.917956000000004pt; fill: #000" textLength="21.32638079999998" x="170.58" y="29.46610099999998">DEST</text>
<text lengthAdjust="spacingAndGlyphs" style="font-size: 8.720879999999994pt; fill: #000" textLength="31.534368000000057" x="159.0" y="42.60335999999998">Shift Right</text>
<text lengthAdjust="spacingAndGlyphs" style="font-size: 8.720879999999994pt; fill: #000" textLength="28.87147200000001" x="161.70000000000002" y="49.86335999999997">with Zero</text>
<text lengthAdjust="spacingAndGlyphs" style="font-size: 8.720879999999994pt; fill: #000" textLength="29.38164000000006" x="161.159904" y="57.66343199999997">Extension</text>
<text lengthAdjust="spacingAndGlyphs" style="font-size: 8.917956000000004pt; fill: #000" textLength="34.60902100000007" x="155.21969980000003" y="74.04549269999998">Post-Shift</text>
<text lengthAdjust="spacingAndGlyphs" style="font-size: 8.918503499999986pt; fill: #000" textLength="53.6597218" x="386.5201245" y="79.02610099999998">X0 &gt;&gt; COUNT</text>
<text lengthAdjust="spacingAndGlyphs" style="font-size: 8.917956000000004pt; fill: #000" textLength="53.65973149999999" x="198.9001148" y="79.02610099999998">X3 &gt;&gt; COUNT</text>
<text lengthAdjust="spacingAndGlyphs" style="font-size: 8.917956000000004pt; fill: #000" textLength="53.61479029999998" x="262.6803064" y="79.02610099999998">X2 &gt;&gt; COUNT</text>
<text lengthAdjust="spacingAndGlyphs" style="font-size: 8.917956000000004pt; fill: #000" textLength="53.59618460000007" x="325.9205328" y="79.02610099999998">X1 &gt;&gt; COUNT</text>
<text lengthAdjust="spacingAndGlyphs" style="font-size: 8.91795599999999pt; fill: #000" textLength="21.32078709999996" x="169.56" y="82.02610099999997">DEST</text></g></svg>
<figcaption><a href='psrlw_psrld_psrlq.html#fig-4-19'>Figure 4-19</a>. PSRLW, PSRLD, and PSRLQ Instruction Operation Using 64-bit Operand</figcaption></figure>
<p>The (V)PSRLW instruction shifts each of the words in the destination operand to the right by the number of bits specified in the count operand; the (V)PSRLD instruction shifts each of the doublewords in the destination operand; and the PSRLQ instruction shifts the quadword (or quadwords) in the destination operand.</p>
<p>In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p>
<p>Legacy SSE instruction 64-bit operand: The destination operand is an MMX technology register; the count operand can be either an MMX technology register or an 64-bit memory location.</p>
<p>128-bit Legacy SSE version: The destination operand is an XMM register; the count operand can be either an XMM register or a 128-bit memory location, or an 8-bit immediate. If the count operand is a memory address, 128 bits are loaded but the upper 64 bits are ignored. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.</p>
<p>VEX.128 encoded version: The destination operand is an XMM register; the count operand can be either an XMM register or a 128-bit memory location, or an 8-bit immediate. If the count operand is a memory address, 128 bits are loaded but the upper 64 bits are ignored. Bits (MAXVL-1:128) of the destination YMM register are zeroed.</p>
<p>VEX.256 encoded version: The destination operand is a YMM register. The source operand is a YMM register or a memory location. The count operand can come either from an XMM register or a memory location or an 8-bit immediate. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.</p>
<p>EVEX encoded versions: The destination operand is a ZMM register updated according to the writemask. The count operand is either an 8-bit immediate (the immediate count version) or an 8-bit value from an XMM register or a memory location (the variable count version). For the immediate count version, the source operand (the second operand) can be a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location. For the variable count version, the first source operand (the second operand) is a ZMM register, the second source operand (the third operand, 8-bit variable count) can be an XMM register or a memory location.</p>
<p>Note: In VEX/EVEX encoded versions of shifts with an immediate count, vvvv of VEX/EVEX encode the destination register, and VEX.B/EVEX.B + ModRM.r/m encodes the source register.</p>
<p>Note: For shifts with an immediate count (VEX.128.66.0F 71-73 /2, or EVEX.128.66.0F 71-73 /2), VEX.vvvv/EVEX.vvvv encodes the destination register.</p>
<h2 id="operation">Operation<a class="anchor" href="#operation">
			¶
		</a></h2>
<h3 id="psrlw--with-64-bit-operand-">PSRLW (With 64-bit Operand)<a class="anchor" href="#psrlw--with-64-bit-operand-">
			¶
		</a></h3>
<pre>IF (COUNT &gt; 15)
THEN
    DEST[64:0] := 0000000000000000H
ELSE
    DEST[15:0] := ZeroExtend(DEST[15:0] &gt;&gt; COUNT);
    (* Repeat shift operation for 2nd and 3rd words *)
    DEST[63:48] := ZeroExtend(DEST[63:48] &gt;&gt; COUNT);
FI;
</pre>
<h3 id="psrld--with-64-bit-operand-">PSRLD (With 64-bit Operand)<a class="anchor" href="#psrld--with-64-bit-operand-">
			¶
		</a></h3>
<pre>IF (COUNT &gt; 31)
THEN
    DEST[64:0] := 0000000000000000H
ELSE
    DEST[31:0] := ZeroExtend(DEST[31:0] &gt;&gt; COUNT);
    DEST[63:32] := ZeroExtend(DEST[63:32] &gt;&gt; COUNT);
FI;
</pre>
<h3 id="psrlq--with-64-bit-operand-">PSRLQ (With 64-bit Operand)<a class="anchor" href="#psrlq--with-64-bit-operand-">
			¶
		</a></h3>
<pre>    IF (COUNT &gt; 63)
    THEN
        DEST[64:0] := 0000000000000000H
    ELSE
        DEST := ZeroExtend(DEST &gt;&gt; COUNT);
    FI;
LOGICAL_RIGHT_SHIFT_DWORDS1(SRC, COUNT_SRC)
COUNT := COUNT_SRC[63:0];
IF (COUNT &gt; 31)
THEN
    DEST[31:0] := 0
ELSE
    DEST[31:0] := ZeroExtend(SRC[31:0] &gt;&gt; COUNT);
FI;
LOGICAL_RIGHT_SHIFT_QWORDS1(SRC, COUNT_SRC)
COUNT := COUNT_SRC[63:0];
IF (COUNT &gt; 63)
THEN
    DEST[63:0] := 0
ELSE
    DEST[63:0] := ZeroExtend(SRC[63:0] &gt;&gt; COUNT);
FI;
LOGICAL_RIGHT_SHIFT_WORDS_256b(SRC, COUNT_SRC)
COUNT := COUNT_SRC[63:0];
IF (COUNT &gt; 15)
THEN
    DEST[255:0] := 0
ELSE
    DEST[15:0] := ZeroExtend(SRC[15:0] &gt;&gt; COUNT);
    (* Repeat shift operation for 2nd through 15th words *)
    DEST[255:240] := ZeroExtend(SRC[255:240] &gt;&gt; COUNT);
FI;
LOGICAL_RIGHT_SHIFT_WORDS(SRC, COUNT_SRC)
COUNT := COUNT_SRC[63:0];
IF (COUNT &gt; 15)
THEN
    DEST[127:0] := 00000000000000000000000000000000H
ELSE
    DEST[15:0] := ZeroExtend(SRC[15:0] &gt;&gt; COUNT);
    (* Repeat shift operation for 2nd through 7th words *)
    DEST[127:112] := ZeroExtend(SRC[127:112] &gt;&gt; COUNT);
FI;
LOGICAL_RIGHT_SHIFT_DWORDS_256b(SRC, COUNT_SRC)
COUNT := COUNT_SRC[63:0];
IF (COUNT &gt; 31)
THEN
    DEST[255:0] := 0
ELSE
    DEST[31:0] := ZeroExtend(SRC[31:0] &gt;&gt; COUNT);
    (* Repeat shift operation for 2nd through 3rd words *)
    DEST[255:224] := ZeroExtend(SRC[255:224] &gt;&gt; COUNT);
FI;
LOGICAL_RIGHT_SHIFT_DWORDS(SRC, COUNT_SRC)
COUNT := COUNT_SRC[63:0];
IF (COUNT &gt; 31)
THEN
    DEST[127:0] := 00000000000000000000000000000000H
ELSE
    DEST[31:0] := ZeroExtend(SRC[31:0] &gt;&gt; COUNT);
    (* Repeat shift operation for 2nd through 3rd words *)
    DEST[127:96] := ZeroExtend(SRC[127:96] &gt;&gt; COUNT);
FI;
LOGICAL_RIGHT_SHIFT_QWORDS_256b(SRC, COUNT_SRC)
COUNT := COUNT_SRC[63:0];
IF (COUNT &gt; 63)
THEN
    DEST[255:0] := 0
ELSE
    DEST[63:0] := ZeroExtend(SRC[63:0] &gt;&gt; COUNT);
    DEST[127:64] := ZeroExtend(SRC[127:64] &gt;&gt; COUNT);
    DEST[191:128] := ZeroExtend(SRC[191:128] &gt;&gt; COUNT);
    DEST[255:192] := ZeroExtend(SRC[255:192] &gt;&gt; COUNT);
FI;
LOGICAL_RIGHT_SHIFT_QWORDS(SRC, COUNT_SRC)
COUNT := COUNT_SRC[63:0];
IF (COUNT &gt; 63)
THEN
    DEST[127:0] := 00000000000000000000000000000000H
ELSE
    DEST[63:0] := ZeroExtend(SRC[63:0] &gt;&gt; COUNT);
    DEST[127:64] := ZeroExtend(SRC[127:64] &gt;&gt; COUNT);
FI;
</pre>
<h3 id="vpsrlw--evex-versions--xmm-m128-">VPSRLW (EVEX Versions, xmm/m128)<a class="anchor" href="#vpsrlw--evex-versions--xmm-m128-">
			¶
		</a></h3>
<pre>(KL, VL) = (8, 128), (16, 256), (32, 512)
IF VL = 128
    TMP_DEST[127:0] := LOGICAL_RIGHT_SHIFT_WORDS_128b(SRC1[127:0], SRC2)
FI;
IF VL = 256
    TMP_DEST[255:0] := LOGICAL_RIGHT_SHIFT_WORDS_256b(SRC1[255:0], SRC2)
FI;
IF VL = 512
    TMP_DEST[255:0] := LOGICAL_RIGHT_SHIFT_WORDS_256b(SRC1[255:0], SRC2)
    TMP_DEST[511:256] := LOGICAL_RIGHT_SHIFT_WORDS_256b(SRC1[511:256], SRC2)
FI;
FOR j := 0 TO KL-1
    i := j * 16
    IF k1[j] OR *no writemask*
        THEN DEST[i+15:i] := TMP_DEST[i+15:i]
        ELSE
            IF *merging-masking*
                        ; merging-masking
                THEN *DEST[i+15:i] remains unchanged*
                ELSE *zeroing-masking*
                            ; zeroing-masking
                    DEST[i+15:i] = 0
            FI
    FI;
ENDFOR
DEST[MAXVL-1:VL] := 0
</pre>
<h3 id="vpsrlw--evex-versions--imm8-">VPSRLW (EVEX Versions, imm8)<a class="anchor" href="#vpsrlw--evex-versions--imm8-">
			¶
		</a></h3>
<pre>(KL, VL) = (8, 128), (16, 256), (32, 512)
IF VL = 128
    TMP_DEST[127:0] := LOGICAL_RIGHT_SHIFT_WORDS_128b(SRC1[127:0], imm8)
FI;
IF VL = 256
    TMP_DEST[255:0] := LOGICAL_RIGHT_SHIFT_WORDS_256b(SRC1[255:0], imm8)
FI;
IF VL = 512
    TMP_DEST[255:0] := LOGICAL_RIGHT_SHIFT_WORDS_256b(SRC1[255:0], imm8)
    TMP_DEST[511:256] := LOGICAL_RIGHT_SHIFT_WORDS_256b(SRC1[511:256], imm8)
FI;
FOR j := 0 TO KL-1
    i := j * 16
    IF k1[j] OR *no writemask*
        THEN DEST[i+15:i] := TMP_DEST[i+15:i]
        ELSE
            IF *merging-masking*
                        ; merging-masking
                THEN *DEST[i+15:i] remains unchanged*
                ELSE *zeroing-masking*
                            ; zeroing-masking
                    DEST[i+15:i] = 0
            FI
    FI;
ENDFOR
DEST[MAXVL-1:VL] := 0
</pre>
<h3 id="vpsrlw--ymm--ymm--xmm-m128----vex-256-encoding">VPSRLW (ymm, ymm, xmm/m128) - VEX.256 Encoding<a class="anchor" href="#vpsrlw--ymm--ymm--xmm-m128----vex-256-encoding">
			¶
		</a></h3>
<pre>DEST[255:0] := LOGICAL_RIGHT_SHIFT_WORDS_256b(SRC1, SRC2)
DEST[MAXVL-1:256] := 0;
</pre>
<h3 id="vpsrlw--ymm--imm8----vex-256-encoding">VPSRLW (ymm, imm8) - VEX.256 Encoding<a class="anchor" href="#vpsrlw--ymm--imm8----vex-256-encoding">
			¶
		</a></h3>
<pre>DEST[255:0] := LOGICAL_RIGHT_SHIFT_WORDS_256b(SRC1, imm8)
DEST[MAXVL-1:256] := 0;
</pre>
<h3 id="vpsrlw--xmm--xmm--xmm-m128----vex-128-encoding">VPSRLW (xmm, xmm, xmm/m128) - VEX.128 Encoding<a class="anchor" href="#vpsrlw--xmm--xmm--xmm-m128----vex-128-encoding">
			¶
		</a></h3>
<pre>DEST[127:0] := LOGICAL_RIGHT_SHIFT_WORDS(SRC1, SRC2)
DEST[MAXVL-1:128] := 0
</pre>
<h3 id="vpsrlw--xmm--imm8----vex-128-encoding">VPSRLW (xmm, imm8) - VEX.128 Encoding<a class="anchor" href="#vpsrlw--xmm--imm8----vex-128-encoding">
			¶
		</a></h3>
<pre>DEST[127:0] := LOGICAL_RIGHT_SHIFT_WORDS(SRC1, imm8)
DEST[MAXVL-1:128] := 0
</pre>
<h3 id="psrlw--xmm--xmm--xmm-m128-">PSRLW (xmm, xmm, xmm/m128)<a class="anchor" href="#psrlw--xmm--xmm--xmm-m128-">
			¶
		</a></h3>
<pre>DEST[127:0] := LOGICAL_RIGHT_SHIFT_WORDS(DEST, SRC)
DEST[MAXVL-1:128] (Unmodified)
</pre>
<h3 id="psrlw--xmm--imm8-">PSRLW (xmm, imm8)<a class="anchor" href="#psrlw--xmm--imm8-">
			¶
		</a></h3>
<pre>DEST[127:0] := LOGICAL_RIGHT_SHIFT_WORDS(DEST, imm8)
DEST[MAXVL-1:128] (Unmodified)
</pre>
<h3 id="vpsrld--evex-versions--xmm-m128-">VPSRLD (EVEX Versions, xmm/m128)<a class="anchor" href="#vpsrld--evex-versions--xmm-m128-">
			¶
		</a></h3>
<pre>(KL, VL) = (4, 128), (8, 256), (16, 512)
IF VL = 128
    TMP_DEST[127:0] := LOGICAL_RIGHT_SHIFT_DWORDS_128b(SRC1[127:0], SRC2)
FI;
IF VL = 256
    TMP_DEST[255:0] := LOGICAL_RIGHT_SHIFT_DWORDS_256b(SRC1[255:0], SRC2)
FI;
IF VL = 512
    TMP_DEST[255:0] := LOGICAL_RIGHT_SHIFT_DWORDS_256b(SRC1[255:0], SRC2)
    TMP_DEST[511:256] := LOGICAL_RIGHT_SHIFT_DWORDS_256b(SRC1[511:256], SRC2)
FI;
FOR j := 0 TO KL-1
    i := j * 32
    IF k1[j] OR *no writemask*
        THEN DEST[i+31:i] := TMP_DEST[i+31:i]
        ELSE
            IF *merging-masking*
                        ; merging-masking
                THEN *DEST[i+31:i] remains unchanged*
                ELSE *zeroing-masking*
                            ; zeroing-masking
                    DEST[i+31:i] := 0
            FI
    FI;
ENDFOR
DEST[MAXVL-1:VL] := 0
</pre>
<h3 id="vpsrld--evex-versions--imm8-">VPSRLD (EVEX Versions, imm8)<a class="anchor" href="#vpsrld--evex-versions--imm8-">
			¶
		</a></h3>
<pre>(KL, VL) = (4, 128), (8, 256), (16, 512)
FOR j := 0 TO KL-1
    i := j * 32
    IF k1[j] OR *no writemask* THEN
            IF (EVEX.b = 1) AND (SRC1 *is memory*)
                THEN DEST[i+31:i] := LOGICAL_RIGHT_SHIFT_DWORDS1(SRC1[31:0], imm8)
                ELSE DEST[i+31:i] := LOGICAL_RIGHT_SHIFT_DWORDS1(SRC1[i+31:i], imm8)
            FI;
        ELSE
            IF *merging-masking* ; merging-masking
                THEN *DEST[i+31:i] remains unchanged*
                ELSE *zeroing-masking*
                        ; zeroing-masking
                    DEST[i+31:i] := 0
            FI
    FI;
ENDFOR
DEST[MAXVL-1:VL] := 0
</pre>
<h3 id="vpsrld--ymm--ymm--xmm-m128----vex-256-encoding">VPSRLD (ymm, ymm, xmm/m128) - VEX.256 Encoding<a class="anchor" href="#vpsrld--ymm--ymm--xmm-m128----vex-256-encoding">
			¶
		</a></h3>
<pre>DEST[255:0] := LOGICAL_RIGHT_SHIFT_DWORDS_256b(SRC1, SRC2)
DEST[MAXVL-1:256] := 0;
</pre>
<h3 id="vpsrld--ymm--imm8----vex-256-encoding">VPSRLD (ymm, imm8) - VEX.256 Encoding<a class="anchor" href="#vpsrld--ymm--imm8----vex-256-encoding">
			¶
		</a></h3>
<pre>DEST[255:0] := LOGICAL_RIGHT_SHIFT_DWORDS_256b(SRC1, imm8)
DEST[MAXVL-1:256] := 0;
</pre>
<h3 id="vpsrld--xmm--xmm--xmm-m128----vex-128-encoding">VPSRLD (xmm, xmm, xmm/m128) - VEX.128 Encoding<a class="anchor" href="#vpsrld--xmm--xmm--xmm-m128----vex-128-encoding">
			¶
		</a></h3>
<pre>DEST[127:0] := LOGICAL_RIGHT_SHIFT_DWORDS(SRC1, SRC2)
DEST[MAXVL-1:128] := 0
</pre>
<h3 id="vpsrld--xmm--imm8----vex-128-encoding">VPSRLD (xmm, imm8) - VEX.128 Encoding<a class="anchor" href="#vpsrld--xmm--imm8----vex-128-encoding">
			¶
		</a></h3>
<pre>DEST[127:0] := LOGICAL_RIGHT_SHIFT_DWORDS(SRC1, imm8)
DEST[MAXVL-1:128] := 0
</pre>
<h3 id="psrld--xmm--xmm--xmm-m128-">PSRLD (xmm, xmm, xmm/m128)<a class="anchor" href="#psrld--xmm--xmm--xmm-m128-">
			¶
		</a></h3>
<pre>DEST[127:0] := LOGICAL_RIGHT_SHIFT_DWORDS(DEST, SRC)
DEST[MAXVL-1:128] (Unmodified)
</pre>
<h3 id="psrld--xmm--imm8-">PSRLD (xmm, imm8)<a class="anchor" href="#psrld--xmm--imm8-">
			¶
		</a></h3>
<pre>DEST[127:0] := LOGICAL_RIGHT_SHIFT_DWORDS(DEST, imm8)
DEST[MAXVL-1:128] (Unmodified)
</pre>
<h3 id="vpsrlq--evex-versions--xmm-m128-">VPSRLQ (EVEX Versions, xmm/m128)<a class="anchor" href="#vpsrlq--evex-versions--xmm-m128-">
			¶
		</a></h3>
<pre>(KL, VL) = (2, 128), (4, 256), (8, 512)
TMP_DEST[255:0] := LOGICAL_RIGHT_SHIFT_QWORDS_256b(SRC1[255:0], SRC2)
TMP_DEST[511:256] := LOGICAL_RIGHT_SHIFT_QWORDS_256b(SRC1[511:256], SRC2)
IF VL = 128
    TMP_DEST[127:0] := LOGICAL_RIGHT_SHIFT_QWORDS_128b(SRC1[127:0], SRC2)
FI;
IF VL = 256
    TMP_DEST[255:0] := LOGICAL_RIGHT_SHIFT_QWORDS_256b(SRC1[255:0], SRC2)
FI;
IF VL = 512
    TMP_DEST[255:0] := LOGICAL_RIGHT_SHIFT_QWORDS_256b(SRC1[255:0], SRC2)
    TMP_DEST[511:256] := LOGICAL_RIGHT_SHIFT_QWORDS_256b(SRC1[511:256], SRC2)
FI;
FOR j := 0 TO KL-1
    i := j * 64
    IF k1[j] OR *no writemask*
        THEN DEST[i+63:i] := TMP_DEST[i+63:i]
        ELSE
            IF *merging-masking*
                        ; merging-masking
                THEN *DEST[i+63:i] remains unchanged*
                ELSE *zeroing-masking*
                            ; zeroing-masking
                    DEST[i+63:i] := 0
            FI
    FI;
ENDFOR
DEST[MAXVL-1:VL] := 0
</pre>
<h3 id="vpsrlq--evex-versions--imm8-">VPSRLQ (EVEX Versions, imm8)<a class="anchor" href="#vpsrlq--evex-versions--imm8-">
			¶
		</a></h3>
<pre>(KL, VL) = (2, 128), (4, 256), (8, 512)
FOR j := 0 TO KL-1
    i := j * 64
    IF k1[j] OR *no writemask* THEN
            IF (EVEX.b = 1) AND (SRC1 *is memory*)
                THEN DEST[i+63:i] := LOGICAL_RIGHT_SHIFT_QWORDS1(SRC1[63:0], imm8)
                ELSE DEST[i+63:i] := LOGICAL_RIGHT_SHIFT_QWORDS1(SRC1[i+63:i], imm8)
            FI;
        ELSE
            IF *merging-masking* ; merging-masking
                THEN *DEST[i+63:i] remains unchanged*
                ELSE *zeroing-masking*
                        ; zeroing-masking
                    DEST[i+63:i] := 0
            FI
    FI;
ENDFOR
DEST[MAXVL-1:VL] := 0
</pre>
<h3 id="vpsrlq--ymm--ymm--xmm-m128----vex-256-encoding">VPSRLQ (ymm, ymm, xmm/m128) - VEX.256 Encoding<a class="anchor" href="#vpsrlq--ymm--ymm--xmm-m128----vex-256-encoding">
			¶
		</a></h3>
<pre>DEST[255:0] := LOGICAL_RIGHT_SHIFT_QWORDS_256b(SRC1, SRC2)
DEST[MAXVL-1:256] := 0;
</pre>
<h3 id="vpsrlq--ymm--imm8----vex-256-encoding">VPSRLQ (ymm, imm8) - VEX.256 Encoding<a class="anchor" href="#vpsrlq--ymm--imm8----vex-256-encoding">
			¶
		</a></h3>
<pre>DEST[255:0] := LOGICAL_RIGHT_SHIFT_QWORDS_256b(SRC1, imm8)
DEST[MAXVL-1:256] := 0;
</pre>
<h3 id="vpsrlq--xmm--xmm--xmm-m128----vex-128-encoding">VPSRLQ (xmm, xmm, xmm/m128) - VEX.128 Encoding<a class="anchor" href="#vpsrlq--xmm--xmm--xmm-m128----vex-128-encoding">
			¶
		</a></h3>
<pre>DEST[127:0] := LOGICAL_RIGHT_SHIFT_QWORDS(SRC1, SRC2)
DEST[MAXVL-1:128] := 0
</pre>
<h3 id="vpsrlq--xmm--imm8----vex-128-encoding">VPSRLQ (xmm, imm8) - VEX.128 Encoding<a class="anchor" href="#vpsrlq--xmm--imm8----vex-128-encoding">
			¶
		</a></h3>
<pre>DEST[127:0] := LOGICAL_RIGHT_SHIFT_QWORDS(SRC1, imm8)
DEST[MAXVL-1:128] := 0
</pre>
<h3 id="psrlq--xmm--xmm--xmm-m128-">PSRLQ (xmm, xmm, xmm/m128)<a class="anchor" href="#psrlq--xmm--xmm--xmm-m128-">
			¶
		</a></h3>
<pre>DEST[127:0] := LOGICAL_RIGHT_SHIFT_QWORDS(DEST, SRC)
DEST[MAXVL-1:128] (Unmodified)
</pre>
<h3 id="psrlq--xmm--imm8-">PSRLQ (xmm, imm8)<a class="anchor" href="#psrlq--xmm--imm8-">
			¶
		</a></h3>
<pre>DEST[127:0] := LOGICAL_RIGHT_SHIFT_QWORDS(DEST, imm8)
DEST[MAXVL-1:128] (Unmodified)
</pre>
<h2 id="intel-c-c++-compiler-intrinsic-equivalents">Intel C/C++ Compiler Intrinsic Equivalents<a class="anchor" href="#intel-c-c++-compiler-intrinsic-equivalents">
			¶
		</a></h2>
<pre>VPSRLD __m512i _mm512_srli_epi32(__m512i a, unsigned int imm);
</pre>
<pre>VPSRLD __m512i _mm512_mask_srli_epi32(__m512i s, __mmask16 k, __m512i a, unsigned int imm);
</pre>
<pre>VPSRLD __m512i _mm512_maskz_srli_epi32( __mmask16 k, __m512i a, unsigned int imm);
</pre>
<pre>VPSRLD __m256i _mm256_mask_srli_epi32(__m256i s, __mmask8 k, __m256i a, unsigned int imm);
</pre>
<pre>VPSRLD __m256i _mm256_maskz_srli_epi32( __mmask8 k, __m256i a, unsigned int imm);
</pre>
<pre>VPSRLD __m128i _mm_mask_srli_epi32(__m128i s, __mmask8 k, __m128i a, unsigned int imm);
</pre>
<pre>VPSRLD __m128i _mm_maskz_srli_epi32( __mmask8 k, __m128i a, unsigned int imm);
</pre>
<pre>VPSRLD __m512i _mm512_srl_epi32(__m512i a, __m128i cnt);
</pre>
<pre>VPSRLD __m512i _mm512_mask_srl_epi32(__m512i s, __mmask16 k, __m512i a, __m128i cnt);
</pre>
<pre>VPSRLD __m512i _mm512_maskz_srl_epi32( __mmask16 k, __m512i a, __m128i cnt);
</pre>
<pre>VPSRLD __m256i _mm256_mask_srl_epi32(__m256i s, __mmask8 k, __m256i a, __m128i cnt);
</pre>
<pre>VPSRLD __m256i _mm256_maskz_srl_epi32( __mmask8 k, __m256i a, __m128i cnt);
</pre>
<pre>VPSRLD __m128i _mm_mask_srl_epi32(__m128i s, __mmask8 k, __m128i a, __m128i cnt);
</pre>
<pre>VPSRLD __m128i _mm_maskz_srl_epi32( __mmask8 k, __m128i a, __m128i cnt);
</pre>
<pre>VPSRLQ __m512i _mm512_srli_epi64(__m512i a, unsigned int imm);
</pre>
<pre>VPSRLQ __m512i _mm512_mask_srli_epi64(__m512i s, __mmask8 k, __m512i a, unsigned int imm);
</pre>
<pre>VPSRLQ __m512i _mm512_mask_srli_epi64( __mmask8 k, __m512i a, unsigned int imm);
</pre>
<pre>VPSRLQ __m256i _mm256_mask_srli_epi64(__m256i s, __mmask8 k, __m256i a, unsigned int imm);
</pre>
<pre>VPSRLQ __m256i _mm256_maskz_srli_epi64( __mmask8 k, __m256i a, unsigned int imm);
</pre>
<pre>VPSRLQ __m128i _mm_mask_srli_epi64(__m128i s, __mmask8 k, __m128i a, unsigned int imm);
</pre>
<pre>VPSRLQ __m128i _mm_maskz_srli_epi64( __mmask8 k, __m128i a, unsigned int imm);
</pre>
<pre>VPSRLQ __m512i _mm512_srl_epi64(__m512i a, __m128i cnt);
</pre>
<pre>VPSRLQ __m512i _mm512_mask_srl_epi64(__m512i s, __mmask8 k, __m512i a, __m128i cnt);
</pre>
<pre>VPSRLQ __m512i _mm512_mask_srl_epi64( __mmask8 k, __m512i a, __m128i cnt);
</pre>
<pre>VPSRLQ __m256i _mm256_mask_srl_epi64(__m256i s, __mmask8 k, __m256i a, __m128i cnt);
</pre>
<pre>VPSRLQ __m256i _mm256_maskz_srl_epi64( __mmask8 k, __m256i a, __m128i cnt);
</pre>
<pre>VPSRLQ __m128i _mm_mask_srl_epi64(__m128i s, __mmask8 k, __m128i a, __m128i cnt);
</pre>
<pre>VPSRLQ __m128i _mm_maskz_srl_epi64( __mmask8 k, __m128i a, __m128i cnt);
</pre>
<pre>VPSRLW __m512i _mm512_srli_epi16(__m512i a, unsigned int imm);
</pre>
<pre>VPSRLW __m512i _mm512_mask_srli_epi16(__m512i s, __mmask32 k, __m512i a, unsigned int imm);
</pre>
<pre>VPSRLW __m512i _mm512_maskz_srli_epi16( __mmask32 k, __m512i a, unsigned int imm);
</pre>
<pre>VPSRLW __m256i _mm256_mask_srli_epi16(__m256i s, __mmask16 k, __m256i a, unsigned int imm);
</pre>
<pre>VPSRLW __m256i _mm256_maskz_srli_epi16( __mmask16 k, __m256i a, unsigned int imm);
</pre>
<pre>VPSRLW __m128i _mm_mask_srli_epi16(__m128i s, __mmask8 k, __m128i a, unsigned int imm);
</pre>
<pre>VPSRLW __m128i _mm_maskz_srli_epi16( __mmask8 k, __m128i a, unsigned int imm);
</pre>
<pre>VPSRLW __m512i _mm512_srl_epi16(__m512i a, __m128i cnt);
</pre>
<pre>VPSRLW __m512i _mm512_mask_srl_epi16(__m512i s, __mmask32 k, __m512i a, __m128i cnt);
</pre>
<pre>VPSRLW __m512i _mm512_maskz_srl_epi16( __mmask32 k, __m512i a, __m128i cnt);
</pre>
<pre>VPSRLW __m256i _mm256_mask_srl_epi16(__m256i s, __mmask16 k, __m256i a, __m128i cnt);
</pre>
<pre>VPSRLW __m256i _mm256_maskz_srl_epi16( __mmask8 k, __mmask16 a, __m128i cnt);
</pre>
<pre>VPSRLW __m128i _mm_mask_srl_epi16(__m128i s, __mmask8 k, __m128i a, __m128i cnt);
</pre>
<pre>VPSRLW __m128i _mm_maskz_srl_epi16( __mmask8 k, __m128i a, __m128i cnt);
</pre>
<pre>PSRLW __m64 _mm_srli_pi16(__m64 m, int count)
</pre>
<pre>PSRLW __m64 _mm_srl_pi16 (__m64 m, __m64 count)
</pre>
<pre>(V)PSRLW __m128i _mm_srli_epi16 (__m128i m, int count)
</pre>
<pre>(V)PSRLW __m128i _mm_srl_epi16 (__m128i m, __m128i count)
</pre>
<pre>VPSRLW __m256i _mm256_srli_epi16 (__m256i m, int count)
</pre>
<pre>VPSRLW __m256i _mm256_srl_epi16 (__m256i m, __m128i count)
</pre>
<pre>PSRLD __m64 _mm_srli_pi32 (__m64 m, int count)
</pre>
<pre>PSRLD __m64 _mm_srl_pi32 (__m64 m, __m64 count)
</pre>
<pre>(V)PSRLD __m128i _mm_srli_epi32 (__m128i m, int count)
</pre>
<pre>(V)PSRLD __m128i _mm_srl_epi32 (__m128i m, __m128i count)
</pre>
<pre>VPSRLD __m256i _mm256_srli_epi32 (__m256i m, int count)
</pre>
<pre>VPSRLD __m256i _mm256_srl_epi32 (__m256i m, __m128i count)
</pre>
<pre>PSRLQ __m64 _mm_srli_si64 (__m64 m, int count)
</pre>
<pre>PSRLQ __m64 _mm_srl_si64 (__m64 m, __m64 count)
</pre>
<pre>(V)PSRLQ __m128i _mm_srli_epi64 (__m128i m, int count)
</pre>
<pre>(V)PSRLQ __m128i _mm_srl_epi64 (__m128i m, __m128i count)
</pre>
<pre>VPSRLQ __m256i _mm256_srli_epi64 (__m256i m, int count)
</pre>
<pre>VPSRLQ __m256i _mm256_srl_epi64 (__m256i m, __m128i count)
</pre>
<h2 id="flags-affected">Flags Affected<a class="anchor" href="#flags-affected">
			¶
		</a></h2>
<p>None.</p>
<h2 class="exceptions" id="numeric-exceptions">Numeric Exceptions<a class="anchor" href="#numeric-exceptions">
			¶
		</a></h2>
<p>None.</p>
<h2 class="exceptions" id="other-exceptions">Other Exceptions<a class="anchor" href="#other-exceptions">
			¶
		</a></h2>
<ul>
<li>VEX-encoded instructions:
<ul>
<li>Syntax with RM/RVM operand encoding (A/C in the operand encoding table), see<span class="not-imported">Table 2-21</span>, “Type 4 Class Exception Conditions.”</li>
<li>Syntax with RM/RVM operand encoding (A/C in the operand encoding table), see<span class="not-imported">Table 2-21</span>, “Type 4 Class Exception Conditions.”</li>
<li>Syntax with MI/VMI operand encoding (B/D in the operand encoding table), see<span class="not-imported">Table 2-24</span>, “Type 7 Class Exception Conditions.”</li>
<li>Syntax with MI/VMI operand encoding (B/D in the operand encoding table), see<span class="not-imported">Table 2-24</span>, “Type 7 Class Exception Conditions.”</li></ul></li>
<li>EVEX-encoded VPSRLW (E in the operand encoding table), see Exceptions Type E4NF.nb in <span class="not-imported">Table 2-50</span>, “Type E4NF Class Exception Conditions.”</li>
<li>EVEX-encoded VPSRLD/Q:
<ul>
<li>Syntax with Mem128 tuple type (G in the operand encoding table), see Exceptions Type E4NF.nb in <span class="not-imported">Table 2-50</span>, “Type E4NF Class Exception Conditions.”</li>
<li>Syntax with Mem128 tuple type (G in the operand encoding table), see Exceptions Type E4NF.nb in <span class="not-imported">Table 2-50</span>, “Type E4NF Class Exception Conditions.”</li>
<li>Syntax with Full tuple type (F in the operand encoding table), see<span class="not-imported">Table 2-49</span>, “Type E4 Class Exception Conditions.”</li>
<li>Syntax with Full tuple type (F in the operand encoding table), see<span class="not-imported">Table 2-49</span>, “Type E4 Class Exception Conditions.”</li></ul></li></ul><footer><p>
		This UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be
		inc<span style="opacity: 0.2">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious
		ways. Refer to <a href="../../software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.
	</p></footer></body>
<!-- Mirrored from www.felixcloutier.com/x86/psrlw:psrld:psrlq by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 02 Jun 2025 23:57:49 GMT -->
</html>
